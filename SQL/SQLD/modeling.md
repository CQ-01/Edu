# 1. 데이터 모델링의 이해
## 스키마
- 내부 스키마 : 물리적 저장정보를 나타냄
<br/>
  <span style = "color : red">$\updownarrow$ 물리적</span>
- 개념 스키마 (개념적) : 전체 DB
<br/>
  <span style = "color : red">$\updownarrow$ 논리적</span>
- 외부 스키마 : 개인적 DB

## ERM 모델
> 피터첸, Entity Relationship Model
- ERD : Entity relationship diagram, ERM모델의 산출물
  - 엔티티 그림, 엔티티 배치, 엔티티 관계설정, 관계명 기술, 관계의 참여도 기술, 관계 필수여부
### Entity
> 유용한 정보를 저장하고 관리하기 위한 집합적 존재
- 복수의 인스턴스로 구성
- 복수의 속성 보유
- 유무형에 따른 분류
  - 유형(물리적 형태), 개념(개념적 정보), 사건(업무수행시)
- 발생시점에 따른 분류
  - 기본 : 원래 존재하는 업무, 고유 주식별자
  - 중심 : 다른 엔티티와의 관계로 행위 엔티티 생성
  - 행위 : 자주 바뀌거나 양이 증가
  <br/>
  <span style = "color : green">\* 기본 $\rightarrow$ 중심 $\rightarrow$ 행위</span>

### Attribute
> 인스턴스로 관리하고자 하는 의미상 분리되지 않는 최소의 데이터 단위
- 기본속성 : 업무로부터 추출한 모든 일반적인 속성
- 설계속성 : 업무를 규칙화하기 위해 새로 만들거나 변형, 정의하는 속성
- 파생속성 : 다른 속성에 영향을 받아 발생하는 속성
- 도메인 : 속성에 대한 데이터타입, 크기, 제약사항 지정

### Relationship
> 엔티티의 인스턴스 사이의 논리적인 연관성, 관계 페어링의 집합
<br/>
> 2개의 엔티티 사이에 관심있는 연관규칙이나 정보의 조합이 발생하는가?
- 페어링 : 엔티티 안에 인스턴스가 개별적으로 관계를 가지는 것
- 연관관계(실선) : 항상 이용하는 관계
- 의존관계(점선) : 상대 행위에 의해 발생하는 관계
- 관계차수 : 1대1, 1대다, 다대다
- 관계선택성 : 필수관계, 선택관계

### 식별자
> 엔티티 내에서 인스턴스를 구분하는 구분자, 논리적 단계에 사용
> <br/>
> \* Key는 물리적 단계에 사용
- 대표성여부에 따른 분류
  - 주식별자 : 엔티티 내 각 어커런스를 구분할 수 있음, 타 엔티티와 참조관계 연결

    <span style = "color : green">\* 해당업무에서 자주 이용되는 속성일것, 이름으로 기술되는 것은 no, 복합으로 구성할 경우 너무 많은 속성을 포함하지 않는다</span>
  - 보조식별자 : 대표성 없는 구분자, 타 엔티티와 참조관계 연결하지 않음
- 스스로 생성여부에 따른 분류
  - 내부 : 스스로 생성되는 식별자
  - 외부 : 타 엔티티로부터 받아오는 식별자
- 속성의 수에 따른 분류
  - 단일 : 하나의 속성으로 구성
  - 복합 : 2개 이상의 속성으로 구성
- 대체여부에 따른 분류
  - 본질 : 업무에 의해 만들어지는 식별자
  - 인조 : 인위적으로 만든 식별자
#### 식별자 관계
- 주식별자
  - 부모로부터 받은 식별자를 자식엔티티의 주식별자로 이용
  - 강한 연결관계, 실선 표기
  - 주식별자 관계로만 설정 시 주식별자 증가로 오류 유발
- 비식별자
  - 부모속성을 자식의 일반속성으로 사용
  - 부모없는 자식이 생성될 수 있는 경우
  - 부모와 자식의 생명주기가 다른 경우
  - 여러개의 엔티티가 하나로 통합되었는데 각각의 엔티티가 별도의 관계를 가진 경우
  - 자식엔티티에 별도의 주식별자를 생성하는 것이 더 유리한 경우
  - SQL문장이 길어져 복잡성이 증가되는 것 방지
  - 약한 연결관계, 점선 표기
  - 비식별자 관계로만 설정 시 부모 엔티티와 조인하여 성능 저하

# 2. 데이터 모델과 성능
## 성능 데이터 모델링
> 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 성능 관련 사항이 데이터 모델링에 반영될 수 있도록 하는 것
- 분석/설계(초기) 단계에서 성능을 고려한 모델링을 수행하여 재업무 비용 최소화
- 성능 데이터 모델링 고려사항
  - 1. 데이터 모델링 시 정규화를 정확하게 수행
  - 2. DB 용량산정을 수행
  - 3. DB에 발생되는 트랜잭션의 유형을 파악
  - 4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행
  - 5. 이력모델의 조정, PF/FK 조정, 슈퍼/서브타입 조정
  - 6. 성능관점에서 데이터 모델을 검증
  
## 정규화
> 반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록 하는 것
- 1차 정규화 : 같은 성격, 내용 컬럼이 연속될 때, 컬럼을 제거하고 테이블을 생성
- 2차 정규화 : PK 복합키 구성일 때 부분적 함수 종속 관계 테이블 분리
- 3차 정규화 : PK가 아닌 일반 컬럼에 의존하는 컬럼 분리
- 입력/수정/삭제 성능이 향상

## 반정규화
> 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능향상과 개발운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터모델링 기법
- 조회 시 디스크 I/O가 많거나 경로가 멀어 조인에 의한 성능저하를 막기 위해 수행
- 조인 성능이 향상
### 반정규화 절차
#### 대상조사
  - 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정 범위만을 조회하는 경우
  - 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없는 경우
  - 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별도의 통계 테이블을 생성
  - 테이블에 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우
  
#### 다른방법 유도검토
  - VIEW 사용 : 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 VIEW 사용
  - 클러스터링 : 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 클러스터링을 적용하거나 인덱스를 조정
  - 파티셔닝 : 대량의 데이터는 PK의 성격에 따라 부분적인 파티션으로 분리할 수 있다. 파티셔닝 키에 의해 물리적 저장공간 분리
  - 캐시 : 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.
  
#### 반정규화 적용
  - 테이블 반정규화
    - 테이블 병합
      - 1:1 관계를 통합하여 성능 향상
      - 1:M 관계를 통합하여 성능 향상
      - 슈퍼/서브 관계를 통합하여 성능 향상
    - 테이블 분할
      - 수직분할 : 칼럼단위 테이블을 디스크 I/O를 분산처리하기 위해 테이블을 1:1로 분리하여 성능향상
      - 수평분할 : 로우단위로 집중발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 로우 단위로 테이블을 쪼갬
    - 테이블 추가
      - 중복 : 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능 향상
      - 통계 : SUM, AVG 등을 미리 수행하여 계산해둠으로써 조회 시 성능을 향상
      - 이력 :  이력 테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 위치시킴으로써 성능 향상
      - 부분 : 하나의 테이블의 전체 컬럼 중 자주 이용하는 집중화된 컬럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 컬럼들을 모아놓은 별도의 반정규화된 테이블을 생성
    - 컬럼 반정규화
      - 중복컬럼 추가 : 조인에 의해 처리할 때 성능저하를 예방하기 위해 중복된 컬럼을 위치시킴
      - 파생컬럼 추가 : 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 컬럼에 보관
      - 이력테이블 컬럼추가 : 대량의 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성 컬럼(최근값 여부, 시작과 종료일자 등)을 추가
      - 응용시스템 오작동을 위한 컬럼 추가 : 업무적으로는 의미가 없으나, 사용자의 실수로 원래 값으로 복구하기 위해 이전 데이터를 임시적으로 중복으로 보관하는 기법
      - PK에 의한 컬럼 추가 : 단일 PK 안에서 특정 값을 별도로 조회하는 경우 성능저하가 발생할 수 있어 일반속성으로 추가
    - 관계 반정규화(무결성 유지)
      - 중복관계 추가 : 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이때 발생할 수 있는 성능저하를 예방하기 위해 추가적인 관계를 맺음

## 분할 테이블
- 로우 체이닝 : 로우의 길이가 너무 길어 두개 이상의 데이터블록에 걸쳐 로우가 저장되어 있음
- 로우 마이그레이션 : 데이터블록에서 수정이 발생하면 수정된 데이터를 해당 데이터블록에 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식
- 로우 체이닝과 로우 마이그레이션으로 많은 블록에 데이터가 저장되면 많은 디스크 I/O가 발생하여 성능저하, 트랜잭션 분석하여 적절한 1:1관계로 분리함으로서 성능향상 추구
- PK에 의한 테이블 분할(파티셔닝)
  - RANGE PARTITION : 대상 테이블이 날짜나 숫자값으로 분리가 가능하고 각 영역별 트랜잭션이 분리되는 경우
  - LIST PARTITION : 지점, 사업소 등 핵심적인 코드값으로 PK가 구성되어 있고 대량의 데이터가 있는 테이블의 경우
  - HASH PARTITION : 지정된 HASH 조건에 따라 해시 알고리즘이 적용되어 테이블 분리
- 테이블 수평/수직 분할 절차
  - 1. 데이터 모델링을 완성한다
  - 2. DB 용량산정을 한다
  - 3. 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 분석한다
  - 4. 집중화된 처리가 컬럼 단위로 발생하는지 로우단위로 발생하는지 분석하여 집중화된 단위로 분리하는 것을 검토
    - 컬럼 많음 $\rightarrow$ 1:1 분리
    - 데이터 많음 $\rightarrow$ 파티셔닝

## 슈퍼/서브 타입 모델
> 업무를 구성하는 데이터를 공통점과 차이점을 고려하여 효과적으로 표현
- 슈퍼 타입 : 공통 부분
- 서브 타입 : 공통으로부터 상속받아 다른 엔티티와 차이가 있는 속성
- 슈퍼/서브타입 데이터 모델의 변환기술
  - 개별로 발생되는 트랜잭션에 대해서는 개별테이블로 구성
  - 슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼+서브타입 테이블로 구성
  - 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성
- 인덱스 특성을 고려한 PK/FK DB 성능향상
  - 여러개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 효율 상승
  - 앞쪽에 위치한 속성값이 가급적 = 또는 최소한 between, <>

## 분산 DB
> 여러 곳으로 분산되어 있는 DB를 하나의 가상 시스템으로 사용할 수 있게 함
> <br/>
> 논리적으로 동일한 시스템에 속하나, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터 집합
### 분산 DB 만족을 위한 6가지 투명성
1. 분할 투명성(단편화) : 하나의 논리적 relation이 여러 단편으로 분할되어 각 사본이 여러 site에 저장
1. 위치 투명성 : 사용하려는 데이터의 저장장소 명시 불필요, 위치정보가 시스템 카탈로그에 유지
1. 지역사상 투명성 : 지역 DBMS와 물리적DB 사이의 Mapping 보장
1. 중복 투명성 : DB 객체가 여러 site에 중복되어 있는지 알 필요가 없음
1. 장애 투명성 : 구성요소의 장애에 무관한 트랜잭션의 원자성 유지
1. 병행 투명성 : 다수 트랜잭션 동시 수행시 결과의 일관성 유지; time stamp, 분산 2단계, Locking 이용
### 분산 DB 장단점
- 장점 : 지역 자치성, 신뢰성 가용성, 효용성 융통성, 빠른 응답속도, 비용절감, 각 지역 사용자 요구 수용
- 단점 : 비용증가, 오류의 잠재성 증대, 설계 관리의 복잡성, 불규칙한 응답속도, 통제의 어려움, 데이터 무결성 위험

### 분산 DB 적용 기법
1. 테이블 위치 분산 : 설계된 테이블을 본사와 지사 단위로 분산, 위치별 DB문서 필요
2. 테이블 분할 분산 : 각각의 테이블을 쪼개어 분산
   - 수평분할 : 로우 단위로 분리, 지사별로 다를때 중복되지 않음
   - 수직분할 : 컬럼 단위로 분리, 각 테이블에 동일 PK 있어야 함
3. 테이블 복제 분산 : 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리
   - 부분 복제 : 마스터DB 에서 테이블의 일부의 내용만 다른 지역이나 서버에 위치
   - 광역 복제 : 마스터DB 테이블의 내용을 각 지역이나 서버에 위치
4. 테이블 요약 분산 : 지역 간 또는 서버 간에 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우
   - 분석 요약 : 동일 테이블 구조를 가지며, 분산되어 있는 동일한 내용의 데이터를 이용하여 통합된 데이터를 산출
   - 통합 요약 : 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출

### 분산DB 설계를 고려해야 하는 경우
1. 성능이 중요한 사이트
2. 공통코드, 기준정보, 마스터 데이터의 성능 향상
3. 실시간 동기화가 요구되지 않는 경우, Near Real Time 특징을 가진 경우
4. 특정 서버에 부하가 집중되어 부하를 분산해야 할 경우
5. 백업 사이트를 구성하는 경우